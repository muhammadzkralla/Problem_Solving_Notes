[abc383C - Humidifier 3](https://atcoder.jp/contests/abc383/tasks/abc383_c "abc383C - Humidifier 3") <br>
We would start a BFS starting from the nodes with value `H`, which corresponds to a humidifier, and test each other nodes if they are with the value `.` and the distance between the two nodes does not exceed `d` and keep track of their count. <br>


[2685. Count the Number of Complete Components](https://leetcode.com/problems/count-the-number-of-complete-components/ "2685. Count the Number of Complete Components") <br>
We will do a simple BFS on each node in the graph and for each BFS call we track the nodes we visited on each iteration `nodes`, and after all the iterations are done, we iterate over all the visited nodes in the `nodes` array  to check if each one have number of edges equal to the total visited nodes in the current BFS search - 1, that's is `node.size() - 1`. <br>

[2503. Maximum Number of Points From Grid Queries](https://leetcode.com/problems/maximum-number-of-points-from-grid-queries/description/ "2503. Maximum Number of Points From Grid Queries") <br>
We could solve this question by simply iterating over each query and perform a BFS on the grid and that would work but it's inefficient and will get `TLE` starting from test case 16, so we need to optimize this solution. To do so, we will try to perform the BFS on the smallest query only and once wereach a block where we can not proceed more in the grid, we will stop, update the answer, and do BFS on the next node in the sorted queries array. So, first we sort the queries array but we keep track of the indices to properly return the answer array with each index refering to the corresponding qury. After that we will create a priority queue to help us process nodes starting from the minimum one to the maximum one. Now we push the first cell in the grid to the priority queue and mark it as visited to start the BFS from it. Then we iterate over each item in the sorted queries array and continue the BFS from where it stopped last time until it stops again. So, instead of restarting BFS for every query, we sort the queries while keeping their indices, use a priority queue (min-heap) to process cells in increasing order of height, start BFS from (0,0), and expand incrementally until we reach an untraversable block, ensuring efficient processing in O(NM log(NM) + Q log Q) time complexity.
