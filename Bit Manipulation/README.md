[1979B XOR Sequences](https://codeforces.com/contest/1979/problem/B "1979B XOR Sequences") <br>
Convert each of x, and y to their binary representation and you will observe that the answer is always 2 to the power of the length of matching bits from x and y starting from the LSB until the first difference occures. <br>

[67. Add Binary](https://leetcode.com/problems/add-binary/description/ "67. Add Binary") <br>
The same logic like the n-bit adder if you are familiar with logic design. For each index `i`, add the two bits `a[i]` and `b[i]`, and the carry, if the sum is 0, add 0 and carry 0, if the sum is 1, add 1 and carry 0, if the sum is 2, add 0 and carry 1, if the sum is 3, add 1 and carry 1. <br>

[136. Single Number](https://leetcode.com/problems/single-number/description/ "136. Single Number") <br>
For any number x, `x XOR x = 0` and `x XOR 0 = x` <br>

[1988C Increasing Sequence with Fixed OR](https://codeforces.com/contest/1988/problem/C "1988C Increasing Sequence with Fixed OR") <br>
We will construct the list simply by converting the number `n` to its binary form and keep iterating from the LSB to the MSB, unsetting bits, adding them to the list, and then setting them back to add the next number, for example, consider `n` to be 23, that's `10111` in binary, the next number is going to be `10110` which is 22, and the next one will be `10101` which is 21, and the next one will be `10011` which is 19, and so on until we reach the MSB, why so? Because 'orring' needs at least one bit to be set to output one, so we keep removing the setted bits from the original number `n` and we gaurantee that the 'orring' the resulting number with the one before it will give `n` as `0 | 1 = 1`. There will be only one edge case for numbers with only one setted bit, for example `2` is `10` so, the next valid number will be `00` which is zero, which is not a positive integer so, the if statement makes sure if the input is a one bit setted number, there's no next integer, just `n` in the list.   <br>